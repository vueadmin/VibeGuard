/**
 * VibeGuard VSCode Extension Entry Point
 * 
 * This extension helps protect non-technical users from security risks
 * when using AI tools to generate code. It provides real-time detection
 * of dangerous patterns like hardcoded API keys, SQL injection risks,
 * and other security vulnerabilities.
 */

import * as vscode from 'vscode';
import { 
  EXTENSION_NAME, 
  COMMANDS, 
  SUCCESS_MESSAGES, 
  ERROR_MESSAGES,
  DIAGNOSTIC_COLLECTION_NAME 
} from './constants';
import { 
  getExtensionConfig, 
  logInfo, 
  logError, 
  showInfoMessage, 
  showErrorMessage 
} from './utils';
import { 
  VibeGuardConfig, 
  IDocumentMonitor, 
  IAnalysisEngine, 
  IRuleEngine,
  IDiagnosticManager,
  IQuickFixProvider 
} from './types';

// Import core components
import { DocumentMonitor } from './monitor/DocumentMonitor';
import { AnalysisEngine } from './analyzer/AnalysisEngine';
import { RuleEngine } from './rules/RuleEngine';
import { DiagnosticManager } from './diagnostics/DiagnosticManager';
import { QuickFixProvider } from './quickfix/QuickFixProvider';

// Import rule definitions
import { registerApiKeyRules } from './rules/definitions/api-keys';
import { registerSqlDangerRules } from './rules/definitions/sql-rules';

/**
 * Extension context and services
 */
interface ExtensionServices {
  config: VibeGuardConfig;
  diagnosticCollection: vscode.DiagnosticCollection;
  documentMonitor: IDocumentMonitor;
  analysisEngine: IAnalysisEngine;
  ruleEngine: IRuleEngine;
  diagnosticManager: IDiagnosticManager;
  quickFixProvider: IQuickFixProvider;
}

let services: ExtensionServices | null = null;

/**
 * Extension activation function
 * Called when the extension is activated
 */
export async function activate(context: vscode.ExtensionContext): Promise<void> {
  try {
    logInfo('Ê≠£Âú®ÊøÄÊ¥ª VibeGuard Êâ©Â±ï...');

    // Initialize configuration
    const config = getExtensionConfig();

    // Initialize core services
    logInfo('Ê≠£Âú®ÂàùÂßãÂåñÊ†∏ÂøÉÊúçÂä°...');
    
    // 1. Initialize Rule Engine
    const ruleEngine = new RuleEngine();
    
    // 2. Initialize Analysis Engine
    const analysisEngine = new AnalysisEngine();
    analysisEngine.setRuleEngine(ruleEngine);
    
    // 3. Initialize Diagnostic Manager
    const diagnosticManager = new DiagnosticManager({
      collectionName: DIAGNOSTIC_COLLECTION_NAME,
      maxDiagnosticsPerFile: 50,
      groupSimilarIssues: true
    });
    
    // Get diagnostic collection from manager and register it
    const diagnosticCollection = diagnosticManager.getDiagnosticCollection();
    context.subscriptions.push(diagnosticCollection);
    
    // 4. Initialize Quick Fix Provider
    const quickFixProvider = new QuickFixProvider(diagnosticCollection);
    
    // 5. Initialize Document Monitor with diagnostic manager
    const documentMonitor = new DocumentMonitor(analysisEngine, diagnosticManager);

    // Connect Analysis Engine to Diagnostic Manager
    connectAnalysisEngineToServices(analysisEngine, diagnosticManager);

    // Initialize services object
    services = {
      config,
      diagnosticCollection,
      documentMonitor,
      analysisEngine,
      ruleEngine,
      diagnosticManager,
      quickFixProvider
    };

    // Register all detection rules
    await registerDetectionRules(ruleEngine);

    // Register VSCode providers and commands
    registerVSCodeProviders(context, quickFixProvider);
    registerCommands(context);
    registerConfigurationChangeListener(context);

    // Start real-time monitoring
    if (config.enableRealTimeAnalysis) {
      documentMonitor.startMonitoring();
      logInfo('ÂÆûÊó∂ÊñáÊ°£ÁõëÊéßÂ∑≤ÂêØÂä®');
    }

    // Show activation message
    logInfo(SUCCESS_MESSAGES.EXTENSION_ACTIVATED);
    
    // Only show user message if this is the first activation
    const isFirstActivation = context.globalState.get('vibeguard.firstActivation', true);
    if (isFirstActivation) {
      showInfoMessage('VibeGuard Â∑≤ÊøÄÊ¥ªÔºÅÊ≠£Âú®‰øùÊä§ÊÇ®ÁöÑ‰ª£Á†ÅÂÆâÂÖ® üõ°Ô∏è');
      await context.globalState.update('vibeguard.firstActivation', false);
    }

    logInfo(`VibeGuard Êâ©Â±ïÊøÄÊ¥ªÂÆåÊàê - Â∑≤Ê≥®ÂÜå ${ruleEngine.getEnabledRules().length} ‰∏™Ê£ÄÊµãËßÑÂàô`);

  } catch (error) {
    logError(error as Error, 'Êâ©Â±ïÊøÄÊ¥ªÂ§±Ë¥•');
    showErrorMessage(ERROR_MESSAGES.EXTENSION_ACTIVATION_FAILED);
    throw error;
  }
}

/**
 * Extension deactivation function
 * Called when the extension is deactivated
 */
export function deactivate(): void {
  try {
    logInfo('Ê≠£Âú®ÂÅúÁî® VibeGuard Êâ©Â±ï...');
    
    // Clean up services
    if (services) {
      // Stop document monitoring
      if (services.documentMonitor) {
        services.documentMonitor.stopMonitoring();
        services.documentMonitor.dispose();
      }
      
      // Dispose analysis engine
      if (services.analysisEngine) {
        services.analysisEngine.dispose();
      }
      
      // Dispose diagnostic manager
      if (services.diagnosticManager) {
        services.diagnosticManager.dispose();
      }
      
      // Dispose diagnostic collection
      if (services.diagnosticCollection) {
        services.diagnosticCollection.dispose();
      }
      
      services = null;
    }
    
    logInfo('VibeGuard Êâ©Â±ïÂ∑≤ÂÅúÁî®');
  } catch (error) {
    logError(error as Error, 'Êâ©Â±ïÂÅúÁî®Êó∂ÂèëÁîüÈîôËØØ');
  }
}

/**
 * Register extension commands
 */
function registerCommands(context: vscode.ExtensionContext): void {
  // Analyze current file command
  const analyzeCurrentFileCommand = vscode.commands.registerCommand(
    COMMANDS.ANALYZE_CURRENT_FILE,
    async () => {
      try {
        const activeEditor = vscode.window.activeTextEditor;
        if (!activeEditor) {
          showInfoMessage('ËØ∑ÂÖàÊâìÂºÄ‰∏Ä‰∏™Êñá‰ª∂');
          return;
        }

        if (!services?.analysisEngine) {
          showErrorMessage('ÂàÜÊûêÂºïÊìéÊú™ÂàùÂßãÂåñ');
          return;
        }

        showInfoMessage('Ê≠£Âú®ÂàÜÊûêÂΩìÂâçÊñá‰ª∂...');
        logInfo(`ÂºÄÂßãÂàÜÊûêÊñá‰ª∂: ${activeEditor.document.fileName}`);
        
        // Perform analysis
        const issues = await services.analysisEngine.analyzeDocument(activeEditor.document);
        
        // Update diagnostics
        if (services.diagnosticManager) {
          services.diagnosticManager.updateDiagnostics(activeEditor.document, issues);
        }
        
        // Show results
        const message = issues.length > 0 
          ? `ÂèëÁé∞ ${issues.length} ‰∏™ÂÆâÂÖ®ÈóÆÈ¢ò` 
          : 'Êú™ÂèëÁé∞ÂÆâÂÖ®ÈóÆÈ¢ò ‚úÖ';
        showInfoMessage(message);
        
        logInfo(`ÂàÜÊûêÂÆåÊàê: ${activeEditor.document.fileName} - ${issues.length} ‰∏™ÈóÆÈ¢ò`);
        
      } catch (error) {
        logError(error as Error, 'ÂàÜÊûêÂΩìÂâçÊñá‰ª∂Â§±Ë¥•');
        showErrorMessage('ÂàÜÊûêÊñá‰ª∂Êó∂ÂèëÁîüÈîôËØØ');
      }
    }
  );

  // Analyze workspace command
  const analyzeWorkspaceCommand = vscode.commands.registerCommand(
    COMMANDS.ANALYZE_WORKSPACE,
    async () => {
      try {
        if (!vscode.workspace.workspaceFolders) {
          showInfoMessage('ËØ∑ÂÖàÊâìÂºÄ‰∏Ä‰∏™Â∑•‰ΩúÂå∫');
          return;
        }

        if (!services?.analysisEngine) {
          showErrorMessage('ÂàÜÊûêÂºïÊìéÊú™ÂàùÂßãÂåñ');
          return;
        }

        showInfoMessage('Ê≠£Âú®ÂàÜÊûêÂ∑•‰ΩúÂå∫Êñá‰ª∂...');
        logInfo('ÂºÄÂßãÂàÜÊûêÂ∑•‰ΩúÂå∫');
        
        // Get all open text documents
        const documents = vscode.workspace.textDocuments;
        let totalIssues = 0;
        let analyzedFiles = 0;
        
        for (const document of documents) {
          if (!document.isUntitled && services.documentMonitor) {
            try {
              const issues = await services.analysisEngine.analyzeDocument(document);
              
              if (services.diagnosticManager) {
                services.diagnosticManager.updateDiagnostics(document, issues);
              }
              
              totalIssues += issues.length;
              analyzedFiles++;
            } catch (error) {
              logError(error as Error, `ÂàÜÊûêÊñá‰ª∂Â§±Ë¥•: ${document.fileName}`);
            }
          }
        }
        
        const message = `Â∑•‰ΩúÂå∫ÂàÜÊûêÂÆåÊàêÔºöÂàÜÊûê‰∫Ü ${analyzedFiles} ‰∏™Êñá‰ª∂ÔºåÂèëÁé∞ ${totalIssues} ‰∏™ÂÆâÂÖ®ÈóÆÈ¢ò`;
        showInfoMessage(message);
        logInfo(message);
        
      } catch (error) {
        logError(error as Error, 'ÂàÜÊûêÂ∑•‰ΩúÂå∫Â§±Ë¥•');
        showErrorMessage('ÂàÜÊûêÂ∑•‰ΩúÂå∫Êó∂ÂèëÁîüÈîôËØØ');
      }
    }
  );

  // Register commands with context
  context.subscriptions.push(analyzeCurrentFileCommand);
  context.subscriptions.push(analyzeWorkspaceCommand);

  logInfo('ÂëΩ‰ª§Ê≥®ÂÜåÂÆåÊàê');
}

/**
 * Register configuration change listener
 */
function registerConfigurationChangeListener(context: vscode.ExtensionContext): void {
  const configChangeListener = vscode.workspace.onDidChangeConfiguration(event => {
    if (event.affectsConfiguration('vibeguard')) {
      try {
        // Update configuration
        if (services) {
          services.config = getExtensionConfig();
          logInfo('ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞');
        }
      } catch (error) {
        logError(error as Error, 'Êõ¥Êñ∞ÈÖçÁΩÆÂ§±Ë¥•');
      }
    }
  });

  context.subscriptions.push(configChangeListener);
}

/**
 * Register all detection rules with the rule engine
 */
async function registerDetectionRules(ruleEngine: IRuleEngine): Promise<void> {
  try {
    logInfo('Ê≠£Âú®Ê≥®ÂÜåÊ£ÄÊµãËßÑÂàô...');
    
    // Register API key detection rules (highest priority)
    registerApiKeyRules(ruleEngine);
    
    // Register SQL danger detection rules
    registerSqlDangerRules(ruleEngine);
    
    const stats = ruleEngine.getStatistics();
    logInfo(`ËßÑÂàôÊ≥®ÂÜåÂÆåÊàê - ÊÄªËÆ°: ${stats.totalRules}, Â∑≤ÂêØÁî®: ${stats.enabledRules}`);
    
  } catch (error) {
    logError(error as Error, 'Ê≥®ÂÜåÊ£ÄÊµãËßÑÂàôÂ§±Ë¥•');
    throw error;
  }
}

/**
 * Connect analysis engine to diagnostic services
 */
function connectAnalysisEngineToServices(
  analysisEngine: IAnalysisEngine,
  diagnosticManager: IDiagnosticManager
): void {
  // The analysis engine will be used by document monitor
  // and the diagnostic manager will be called to update diagnostics
  // This connection is handled through the document monitor workflow
  logInfo('ÂàÜÊûêÂºïÊìéÂ∑≤ËøûÊé•Âà∞ËØäÊñ≠ÊúçÂä°');
}

/**
 * Register VSCode providers
 */
function registerVSCodeProviders(
  context: vscode.ExtensionContext,
  quickFixProvider: IQuickFixProvider
): void {
  try {
    // Register code action provider for quick fixes
    const codeActionProvider = vscode.languages.registerCodeActionsProvider(
      { scheme: 'file' }, // Apply to all file schemes
      quickFixProvider,
      {
        providedCodeActionKinds: [
          vscode.CodeActionKind.QuickFix,
          vscode.CodeActionKind.Refactor,
          vscode.CodeActionKind.SourceFixAll
        ]
      }
    );
    
    context.subscriptions.push(codeActionProvider);
    logInfo('‰ª£Á†ÅÊìç‰ΩúÊèê‰æõËÄÖÂ∑≤Ê≥®ÂÜå');
    
  } catch (error) {
    logError(error as Error, 'Ê≥®ÂÜå VSCode Êèê‰æõËÄÖÂ§±Ë¥•');
    throw error;
  }
}

/**
 * Get current extension services (for use by other modules)
 */
export function getExtensionServices(): ExtensionServices | null {
  return services;
}
