/**
 * Claude Generated Code Test Suite
 * 
 * Tests based on real code patterns commonly generated by Claude.
 * Claude tends to generate more structured code with better practices,
 * but still may include security vulnerabilities that users copy without review.
 */

import * as assert from 'assert';
import * as vscode from 'vscode';
import { activate, getExtensionServices } from '../../extension';
import { SecurityCategory, IssueSeverity } from '../../types';

suite('Real-World Scenarios - Claude Generated Code', () => {
  let context: vscode.ExtensionContext;

  suiteSetup(async () => {
    // Create mock extension context
    context = {
      subscriptions: [],
      workspaceState: { get: () => undefined, update: () => Promise.resolve(), keys: () => [] },
      globalState: { 
        get: (key: string, defaultValue?: any) => {
          if (key === 'vibeguard.firstActivation') return false;
          return defaultValue;
        }, 
        update: () => Promise.resolve(), 
        keys: () => [], 
        setKeysForSync: () => {} 
      },
      extensionUri: vscode.Uri.file(__dirname),
      extensionPath: __dirname,
      asAbsolutePath: (relativePath: string) => relativePath,
      storagePath: undefined,
      globalStoragePath: __dirname,
      logPath: __dirname,
      extensionMode: vscode.ExtensionMode.Test,
      secrets: {
        get: () => Promise.resolve(undefined),
        store: () => Promise.resolve(),
        delete: () => Promise.resolve(),
        onDidChange: new vscode.EventEmitter().event
      },
      environmentVariableCollection: {
        persistent: false,
        replace: () => {}, append: () => {}, prepend: () => {},
        get: () => undefined, forEach: () => {}, delete: () => {}, clear: () => {},
        [Symbol.iterator]: function* () {}
      },
      logUri: vscode.Uri.file(__dirname + '/test.log'),
      storageUri: undefined,
      globalStorageUri: vscode.Uri.file(__dirname),
      extension: {} as any,
      languageModelAccessInformation: {} as any
    } as unknown as vscode.ExtensionContext;

    await activate(context);
  });

  /**
   * Test Case 1: Claude TypeScript API Client
   * Claude often generates well-structured TypeScript with interfaces
   */
  test('Claude TypeScript API Client - Should detect hardcoded credentials', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical Claude TypeScript API client
    const claudeTypeScriptCode = `
interface APIConfig {
  baseUrl: string;
  apiKey: string;
  timeout: number;
}

interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

class APIClient {
  private config: APIConfig;

  constructor(config: APIConfig) {
    this.config = config;
  }

  async getUser(id: string): Promise<User> {
    const response = await fetch(\`\${this.config.baseUrl}/users/\${id}\`, {
      headers: {
        'Authorization': \`Bearer \${this.config.apiKey}\`,
        'Content-Type': 'application/json'
      },
      timeout: this.config.timeout
    });

    if (!response.ok) {
      throw new Error(\`Failed to fetch user: \${response.statusText}\`);
    }

    return response.json();
  }

  async deleteUser(id: string): Promise<void> {
    const response = await fetch(\`\${this.config.baseUrl}/users/\${id}\`, {
      method: 'DELETE',
      headers: {
        'Authorization': \`Bearer \${this.config.apiKey}\`
      }
    });

    if (!response.ok) {
      throw new Error(\`Failed to delete user: \${response.statusText}\`);
    }
  }
}

// Example usage with hardcoded credentials
const apiClient = new APIClient({
  baseUrl: 'https://api.example.com',
  apiKey: 'sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_SHORT', // Hardcoded API key
  timeout: 5000
});

// Alternative configuration with more hardcoded values
const config = {
  openai: {
    apiKey: 'sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_12345',
    organization: 'org-1234567890abcdef'
  },
  database: {
    host: 'localhost',
    username: 'admin',
    password: 'secretpassword123', // Hardcoded password
    database: 'myapp'
  },
  jwt: {
    secret: 'my-super-secret-jwt-key-12345', // Hardcoded JWT secret
    expiresIn: '24h'
  }
};

export { APIClient, config };
`;

    const document = await vscode.workspace.openTextDocument({
      content: claudeTypeScriptCode,
      language: 'typescript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`Claude TypeScript test: Found ${issues.length} issues`);
    
    // Should detect multiple hardcoded credentials
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded API keys and secrets');
    
    // Verify all detected issues are properly categorized
    apiKeyIssues.forEach(issue => {
      assert.strictEqual(issue.severity, IssueSeverity.ERROR, 'API key issues should be ERROR severity');
      assert.ok(issue.message.includes('危险'), 'Message should be in Chinese');
    });

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 2: Claude Database Migration Script
   * Claude often generates comprehensive database scripts
   */
  test('Claude Database Migration - Should detect dangerous SQL operations', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical Claude database migration script
    const claudeDatabaseCode = `
-- Database migration script generated by Claude
-- Migration: Add user roles and permissions

-- Create roles table
CREATE TABLE IF NOT EXISTS roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create permissions table
CREATE TABLE IF NOT EXISTS permissions (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    resource VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add role_id to users table
ALTER TABLE users ADD COLUMN role_id INTEGER REFERENCES roles(id);

-- Insert default roles
INSERT INTO roles (name, description) VALUES 
    ('admin', 'Administrator with full access'),
    ('user', 'Regular user with limited access'),
    ('guest', 'Guest user with read-only access');

-- Clean up old data (DANGEROUS OPERATIONS)
DELETE FROM user_sessions; -- Delete all sessions without WHERE clause
UPDATE users SET last_login = NULL; -- Update all users without WHERE clause
TRUNCATE TABLE audit_logs; -- Truncate entire audit log

-- Drop old tables (DANGEROUS)
DROP TABLE IF EXISTS old_user_data;
DROP TABLE IF EXISTS temp_migration_data;

-- Create admin user with hardcoded password
INSERT INTO users (username, email, password_hash, role_id) VALUES (
    'admin',
    'admin@example.com',
    '$2b$10$hardcoded.hash.for.password123', -- Hardcoded password hash
    (SELECT id FROM roles WHERE name = 'admin')
);

-- Database connection examples in comments
-- Connection string: postgresql://admin:password123@localhost:5432/myapp
-- MongoDB: mongodb://user:secretpass@localhost:27017/mydb
-- Redis: redis://default:redispass@localhost:6379

-- Cleanup script (MORE DANGEROUS OPERATIONS)
-- DELETE FROM users WHERE created_at < '2023-01-01'; -- Commented but still dangerous
-- UPDATE products SET price = 0; -- Mass price update without WHERE
`;

    const document = await vscode.workspace.openTextDocument({
      content: claudeDatabaseCode,
      language: 'sql'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`Claude Database test: Found ${issues.length} issues`);
    
    // Should detect dangerous SQL operations
    const sqlIssues = issues.filter(issue => 
      issue.category === SecurityCategory.SQL_DANGER
    );
    
    const credentialIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY &&
      (issue.message.includes('密码') || issue.message.includes('连接'))
    );
    
    console.log(`SQL issues: ${sqlIssues.length}, Credential issues: ${credentialIssues.length}`);
    
    assert.ok(sqlIssues.length > 0, 'Should detect dangerous SQL operations');
    
    // Verify SQL issues are properly detected
    sqlIssues.forEach(issue => {
      assert.strictEqual(issue.severity, IssueSeverity.ERROR, 'Dangerous SQL should be ERROR severity');
    });

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 3: Claude React Hook with Security Issues
   * Claude generates sophisticated React patterns but may include vulnerabilities
   */
  test('Claude React Custom Hook - Should detect framework vulnerabilities', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical Claude React custom hook
    const claudeReactCode = `
import React, { useState, useEffect, useCallback, useMemo } from 'react';

interface User {
  id: string;
  name: string;
  email: string;
  bio?: string;
}

interface UseUserOptions {
  autoRefresh?: boolean;
  refreshInterval?: number;
}

// Custom hook for user management
export const useUser = (userId: string, options: UseUserOptions = {}) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { autoRefresh = false, refreshInterval = 30000 } = options;

  // Fetch user data
  const fetchUser = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch(\`/api/users/\${userId}\`, {
        headers: {
          'Authorization': 'Bearer sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_12345' // Hardcoded token
        }
      });

      if (!response.ok) {
        throw new Error(\`Failed to fetch user: \${response.statusText}\`);
      }

      const userData = await response.json();
      setUser(userData);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [userId]);

  // Auto-refresh effect with potential infinite loop
  useEffect(() => {
    fetchUser();
    
    if (autoRefresh) {
      const interval = setInterval(fetchUser, refreshInterval);
      return () => clearInterval(interval);
    }
  }, [fetchUser, autoRefresh, refreshInterval]); // Missing userId dependency

  return { user, loading, error, refetch: fetchUser };
};

// Component using the hook with XSS vulnerability
export const UserProfile: React.FC<{ userId: string }> = ({ userId }) => {
  const { user, loading, error } = useUser(userId, { autoRefresh: true });
  const [editMode, setEditMode] = useState(false);
  const [bio, setBio] = useState('');

  useEffect(() => {
    if (user?.bio) {
      setBio(user.bio);
    }
  }, [user]);

  const handleSave = useCallback(async () => {
    try {
      const response = await fetch(\`/api/users/\${userId}\`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer your-hardcoded-token-here' // Another hardcoded token
        },
        body: JSON.stringify({ bio })
      });

      if (!response.ok) {
        throw new Error('Failed to update user');
      }

      setEditMode(false);
    } catch (err) {
      console.error('Update failed:', err);
    }
  }, [userId, bio]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div className="user-profile">
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
      
      {editMode ? (
        <div>
          <textarea
            value={bio}
            onChange={(e) => setBio(e.target.value)}
            placeholder="Enter bio..."
          />
          <button onClick={handleSave}>Save</button>
          <button onClick={() => setEditMode(false)}>Cancel</button>
        </div>
      ) : (
        <div>
          {/* XSS vulnerability: Direct HTML insertion */}
          <div dangerouslySetInnerHTML={{ __html: user.bio || 'No bio available' }} />
          <button onClick={() => setEditMode(true)}>Edit Bio</button>
        </div>
      )}
      
      {/* Code injection vulnerability */}
      <button onClick={() => eval(\`console.log('User: \${user.name}')\`)}>
        Debug User
      </button>
    </div>
  );
};

// Configuration with hardcoded values
export const apiConfig = {
  baseUrl: process.env.REACT_APP_API_URL || 'https://api.example.com',
  apiKey: process.env.REACT_APP_API_KEY || 'fallback-api-key-12345', // Hardcoded fallback
  timeout: 10000,
  retries: 3
};
`;

    const document = await vscode.workspace.openTextDocument({
      content: claudeReactCode,
      language: 'typescript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`Claude React test: Found ${issues.length} issues`);
    
    // Should detect multiple types of issues
    const frameworkIssues = issues.filter(issue => 
      issue.category === SecurityCategory.FRAMEWORK_RISK
    );
    
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    const codeInjectionIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CODE_INJECTION
    );
    
    console.log(`Framework: ${frameworkIssues.length}, API keys: ${apiKeyIssues.length}, Code injection: ${codeInjectionIssues.length}`);
    
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded API tokens');
    assert.ok(codeInjectionIssues.length > 0, 'Should detect eval() usage');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 4: Claude Node.js Microservice
   * Claude often generates comprehensive microservice architectures
   */
  test('Claude Node.js Microservice - Should detect service security issues', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical Claude microservice implementation
    const claudeMicroserviceCode = `
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { Pool } from 'pg';

// Configuration with hardcoded secrets
const config = {
  port: process.env.PORT || 3000,
  jwtSecret: process.env.JWT_SECRET || 'fallback-jwt-secret-key-12345', // Hardcoded fallback
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'microservice',
    user: process.env.DB_USER || 'admin',
    password: process.env.DB_PASSWORD || 'defaultpassword123' // Hardcoded fallback
  },
  redis: {
    url: process.env.REDIS_URL || 'redis://default:redispass@localhost:6379' // Hardcoded credentials
  },
  external: {
    apiKey: 'sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_SHORT', // Hardcoded API key
    webhookSecret: 'webhook-secret-key-12345'
  }
};

const app = express();

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['*'], // Potentially dangerous fallback
  credentials: true
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

app.use(express.json({ limit: '10mb' }));

// Database connection
const pool = new Pool(config.database);

// Authentication middleware
const authenticateToken = (req: any, res: any, next: any) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.sendStatus(401);
  }

  jwt.verify(token, config.jwtSecret, (err: any, user: any) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

// User management endpoints
app.post('/api/users', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // Hash password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    
    // Insert user (potential SQL injection if not using parameterized queries)
    const query = \`
      INSERT INTO users (username, email, password_hash, created_at)
      VALUES ('\${username}', '\${email}', '\${hashedPassword}', NOW())
      RETURNING id, username, email
    \`;
    
    const result = await pool.query(query);
    res.status(201).json(result.rows[0]);
  } catch (error) {
    console.error('User creation error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Admin endpoint with dangerous operations
app.delete('/api/admin/users', authenticateToken, async (req, res) => {
  try {
    // Dangerous: Delete all users without proper WHERE clause
    const result = await pool.query('DELETE FROM users');
    
    res.json({ 
      message: 'All users deleted',
      deletedCount: result.rowCount 
    });
  } catch (error) {
    console.error('Delete error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Data export endpoint with potential command injection
app.get('/api/export/:format', authenticateToken, async (req, res) => {
  try {
    const { format } = req.params;
    const { table } = req.query;
    
    // Command injection vulnerability
    const { exec } = require('child_process');
    const command = \`pg_dump -t \${table} --format=\${format} \${config.database.database}\`;
    
    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error('Export error:', error);
        return res.status(500).json({ error: 'Export failed' });
      }
      
      res.setHeader('Content-Type', 'application/octet-stream');
      res.send(stdout);
    });
  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    config: {
      // Exposing sensitive configuration in health check
      database: config.database,
      jwtSecret: config.jwtSecret.substring(0, 10) + '...',
      apiKey: config.external.apiKey
    }
  });
});

// Error handling middleware
app.use((err: any, req: any, res: any, next: any) => {
  console.error(err.stack);
  
  // Exposing stack traces in production
  res.status(500).json({
    error: 'Something went wrong!',
    stack: process.env.NODE_ENV === 'production' ? undefined : err.stack,
    details: err.message
  });
});

const server = app.listen(config.port, () => {
  console.log(\`Microservice running on port \${config.port}\`);
  console.log('Configuration:', JSON.stringify(config, null, 2)); // Logging sensitive config
});

export default server;
`;

    const document = await vscode.workspace.openTextDocument({
      content: claudeMicroserviceCode,
      language: 'typescript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`Claude Microservice test: Found ${issues.length} issues`);
    
    // Should detect various security issues
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    const sqlIssues = issues.filter(issue => 
      issue.category === SecurityCategory.SQL_DANGER
    );
    
    const codeInjectionIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CODE_INJECTION
    );
    
    const configIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CONFIG_ERROR
    );
    
    console.log(`API keys: ${apiKeyIssues.length}, SQL: ${sqlIssues.length}, Code injection: ${codeInjectionIssues.length}, Config: ${configIssues.length}`);
    
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded API keys and secrets');
    assert.ok(sqlIssues.length > 0, 'Should detect dangerous SQL operations');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 5: Claude Configuration Files
   * Claude generates comprehensive configuration examples
   */
  test('Claude Configuration Files - Should detect configuration vulnerabilities', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical Claude configuration file
    const claudeConfigCode = `
// config/production.js - Production configuration
module.exports = {
  // Server configuration
  server: {
    port: process.env.PORT || 3000,
    host: process.env.HOST || '0.0.0.0',
    
    // Security settings
    cors: {
      origin: process.env.CORS_ORIGIN || '*', // Dangerous: allows all origins
      credentials: true
    },
    
    // SSL configuration
    ssl: {
      enabled: process.env.SSL_ENABLED === 'true',
      key: process.env.SSL_KEY || '/path/to/key.pem',
      cert: process.env.SSL_CERT || '/path/to/cert.pem'
    }
  },

  // Database configuration
  database: {
    type: 'postgresql',
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT) || 5432,
    username: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'defaultpassword123', // Hardcoded fallback
    database: process.env.DB_NAME || 'production_db',
    
    // Connection pool
    pool: {
      min: 2,
      max: 10,
      acquire: 30000,
      idle: 10000
    },
    
    // Logging (dangerous in production)
    logging: process.env.DB_LOGGING === 'true' || true, // Debug enabled by default
    
    // SSL mode
    ssl: process.env.DB_SSL === 'true' ? {
      rejectUnauthorized: false // Dangerous: accepts invalid certificates
    } : false
  },

  // Redis configuration
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT) || 6379,
    password: process.env.REDIS_PASSWORD || 'redispassword123', // Hardcoded fallback
    db: parseInt(process.env.REDIS_DB) || 0,
    
    // Connection options
    retryDelayOnFailover: 100,
    enableReadyCheck: false,
    maxRetriesPerRequest: null
  },

  // JWT configuration
  jwt: {
    secret: process.env.JWT_SECRET || 'super-secret-jwt-key-12345', // Hardcoded fallback
    expiresIn: process.env.JWT_EXPIRES_IN || '24h',
    algorithm: 'HS256'
  },

  // External API keys
  apis: {
    openai: {
      apiKey: process.env.OPENAI_API_KEY || 'sk-proj-EXAMPLE_FALLBACK_OPENAI_KEY', // Hardcoded fallback
      organization: process.env.OPENAI_ORG || 'org-fallback123'
    },
    
    stripe: {
      secretKey: process.env.STRIPE_SECRET_KEY || 'sk_test_EXAMPLE_FALLBACK_KEY',
      publishableKey: process.env.STRIPE_PUBLISHABLE_KEY || 'pk_test_fallback_key_12345'
    },
    
    aws: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID || 'AKIA_EXAMPLE_NOT_REAL_AWS_KEY', // Hardcoded fallback
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || 'fallback-secret-access-key',
      region: process.env.AWS_REGION || 'us-east-1'
    }
  },

  // Logging configuration
  logging: {
    level: process.env.LOG_LEVEL || 'debug', // Debug level in production
    format: 'json',
    
    // File logging
    file: {
      enabled: true,
      filename: 'app.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    },
    
    // Console logging (dangerous in production)
    console: {
      enabled: process.env.CONSOLE_LOGGING !== 'false', // Enabled by default
      colorize: true,
      timestamp: true
    }
  },

  // Security configuration
  security: {
    // Session configuration
    session: {
      secret: process.env.SESSION_SECRET || 'session-secret-key-12345', // Hardcoded fallback
      resave: false,
      saveUninitialized: false,
      
      cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
      }
    },
    
    // Rate limiting
    rateLimit: {
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: process.env.RATE_LIMIT_MAX || 1000, // Very high limit
      message: 'Too many requests from this IP'
    },
    
    // CSRF protection
    csrf: {
      enabled: process.env.CSRF_ENABLED === 'true' || false // Disabled by default
    }
  },

  // Feature flags
  features: {
    debug: process.env.DEBUG === 'true' || true, // Debug enabled by default
    metrics: process.env.METRICS_ENABLED === 'true',
    profiling: process.env.PROFILING_ENABLED === 'true' || true // Profiling enabled
  }
};

// Environment-specific overrides
if (process.env.NODE_ENV === 'development') {
  module.exports.database.logging = true;
  module.exports.logging.level = 'debug';
  module.exports.features.debug = true;
}

// Export configuration
console.log('Loaded configuration:', JSON.stringify(module.exports, null, 2)); // Logging sensitive config
`;

    const document = await vscode.workspace.openTextDocument({
      content: claudeConfigCode,
      language: 'javascript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`Claude Configuration test: Found ${issues.length} issues`);
    
    // Should detect configuration and credential issues
    const configIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CONFIG_ERROR
    );
    
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    console.log(`Config issues: ${configIssues.length}, API key issues: ${apiKeyIssues.length}`);
    
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded API keys and secrets');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  suiteTeardown(async () => {
    // Clean up any remaining documents
    await vscode.commands.executeCommand('workbench.action.closeAllEditors');
  });
});