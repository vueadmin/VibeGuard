/**
 * ChatGPT Generated Code Test Suite
 * 
 * Tests based on real code patterns commonly generated by ChatGPT.
 * These tests ensure VibeGuard can detect security issues in AI-generated code
 * that users might copy-paste without understanding the security implications.
 */

import * as assert from 'assert';
import * as vscode from 'vscode';
import { activate, getExtensionServices } from '../../extension';
import { SecurityCategory, IssueSeverity } from '../../types';

suite('Real-World Scenarios - ChatGPT Generated Code', () => {
  let context: vscode.ExtensionContext;

  suiteSetup(async () => {
    // Create mock extension context
    context = {
      subscriptions: [],
      workspaceState: { get: () => undefined, update: () => Promise.resolve(), keys: () => [] },
      globalState: { 
        get: (key: string, defaultValue?: any) => {
          if (key === 'vibeguard.firstActivation') return false;
          return defaultValue;
        }, 
        update: () => Promise.resolve(), 
        keys: () => [], 
        setKeysForSync: () => {} 
      },
      extensionUri: vscode.Uri.file(__dirname),
      extensionPath: __dirname,
      asAbsolutePath: (relativePath: string) => relativePath,
      storagePath: undefined,
      globalStoragePath: __dirname,
      logPath: __dirname,
      extensionMode: vscode.ExtensionMode.Test,
      secrets: {
        get: () => Promise.resolve(undefined),
        store: () => Promise.resolve(),
        delete: () => Promise.resolve(),
        onDidChange: new vscode.EventEmitter().event
      },
      environmentVariableCollection: {
        persistent: false,
        replace: () => {}, append: () => {}, prepend: () => {},
        get: () => undefined, forEach: () => {}, delete: () => {}, clear: () => {},
        [Symbol.iterator]: function* () {}
      },
      logUri: vscode.Uri.file(__dirname + '/test.log'),
      storageUri: undefined,
      globalStorageUri: vscode.Uri.file(__dirname),
      extension: {} as any,
      languageModelAccessInformation: {} as any
    } as unknown as vscode.ExtensionContext;

    await activate(context);
  });

  /**
   * Test Case 1: ChatGPT OpenAI Integration Example
   * Based on common ChatGPT responses for "how to use OpenAI API"
   */
  test('ChatGPT OpenAI API Integration - Should detect hardcoded API keys', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical ChatGPT response for OpenAI API integration
    const chatgptOpenAICode = `
import OpenAI from 'openai';

// Initialize the OpenAI client
const openai = new OpenAI({
  apiKey: 'sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_12345', // Your API key here
});

async function generateText(prompt) {
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 150,
      temperature: 0.7,
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error('Error generating text:', error);
    throw error;
  }
}

// Example usage
async function main() {
  const prompt = "Write a short story about a robot";
  const story = await generateText(prompt);
  console.log(story);
}

main().catch(console.error);
`;

    const document = await vscode.workspace.openTextDocument({
      content: chatgptOpenAICode,
      language: 'javascript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`ChatGPT OpenAI test: Found ${issues.length} issues`);
    
    // Should detect the hardcoded API key
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY && 
      issue.code.includes('OPENAI')
    );
    
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded OpenAI API key');
    assert.strictEqual(apiKeyIssues[0].severity, IssueSeverity.ERROR, 'API key issue should be ERROR severity');
    assert.ok(apiKeyIssues[0].message.includes('危险'), 'Message should be in Chinese');
    
    // Test quick fix
    services.diagnosticManager.updateDiagnostics(document, issues);
    const diagnostics = vscode.languages.getDiagnostics(document.uri);
    
    if (diagnostics.length > 0) {
      const context: vscode.CodeActionContext = {
        diagnostics: [diagnostics[0]],
        only: undefined,
        triggerKind: vscode.CodeActionTriggerKind.Automatic
      };

      const codeActions = await services.quickFixProvider.provideCodeActions(
        document, diagnostics[0].range, context, new vscode.CancellationTokenSource().token
      );

      assert.ok(codeActions && codeActions.length > 0, 'Should provide quick fix for API key');
      assert.ok(codeActions[0].title.includes('环境变量'), 'Quick fix should suggest environment variable');
    }

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 2: ChatGPT Database Connection Example
   * Based on common ChatGPT responses for database connections
   */
  test('ChatGPT Database Connection - Should detect hardcoded credentials', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical ChatGPT response for database connection
    const chatgptDatabaseCode = `
const mongoose = require('mongoose');
const mysql = require('mysql2');

// MongoDB connection (ChatGPT often provides examples like this)
const mongoUrl = 'mongodb://admin:password123@localhost:27017/myapp';
mongoose.connect(mongoUrl, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

// MySQL connection
const mysqlConnection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'mypassword123',
  database: 'myapp'
});

// PostgreSQL connection string
const pgConnectionString = 'postgresql://user:pass@localhost:5432/mydb';

// Redis connection
const redis = require('redis');
const redisClient = redis.createClient({
  url: 'redis://default:myredispassword@localhost:6379'
});

// Example database operations
async function getUserById(id) {
  // Dangerous SQL without proper parameterization
  const query = \`SELECT * FROM users WHERE id = \${id}\`;
  return mysqlConnection.execute(query);
}

async function deleteInactiveUsers() {
  // Dangerous DELETE without WHERE clause
  const query = "DELETE FROM users";
  return mysqlConnection.execute(query);
}
`;

    const document = await vscode.workspace.openTextDocument({
      content: chatgptDatabaseCode,
      language: 'javascript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`ChatGPT Database test: Found ${issues.length} issues`);
    
    // Should detect multiple types of issues
    const credentialIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY &&
      (issue.message.includes('密码') || issue.message.includes('password') || issue.message.includes('连接'))
    );
    
    const sqlIssues = issues.filter(issue => 
      issue.category === SecurityCategory.SQL_DANGER
    );
    
    assert.ok(credentialIssues.length > 0, 'Should detect hardcoded database credentials');
    assert.ok(sqlIssues.length > 0, 'Should detect dangerous SQL operations');
    
    // Verify severity levels
    credentialIssues.forEach(issue => {
      assert.strictEqual(issue.severity, IssueSeverity.ERROR, 'Credential issues should be ERROR severity');
    });

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 3: ChatGPT React Component with XSS Vulnerability
   * Based on ChatGPT responses for dynamic content rendering
   */
  test('ChatGPT React Component - Should detect XSS vulnerabilities', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical ChatGPT React component with potential XSS
    const chatgptReactCode = `
import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [bio, setBio] = useState('');

  useEffect(() => {
    fetchUser(userId);
  }); // Missing dependency array - infinite loop risk

  const fetchUser = async (id) => {
    const response = await fetch(\`/api/users/\${id}\`);
    const userData = await response.json();
    setUser(userData);
  };

  const handleBioUpdate = (newBio) => {
    setBio(newBio);
  };

  return (
    <div>
      <h1>{user?.name}</h1>
      
      {/* Dangerous: Direct HTML insertion */}
      <div dangerouslySetInnerHTML={{ __html: user?.bio }} />
      
      {/* Another XSS risk */}
      <div dangerouslySetInnerHTML={{ __html: bio }} />
      
      <textarea 
        value={bio}
        onChange={(e) => handleBioUpdate(e.target.value)}
        placeholder="Enter your bio..."
      />
      
      {/* Eval usage - code injection risk */}
      <button onClick={() => eval(\`alert('Hello \${user?.name}')\`)}>
        Greet User
      </button>
    </div>
  );
}

export default UserProfile;
`;

    const document = await vscode.workspace.openTextDocument({
      content: chatgptReactCode,
      language: 'typescript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`ChatGPT React test: Found ${issues.length} issues`);
    
    // Should detect framework-specific risks
    const frameworkIssues = issues.filter(issue => 
      issue.category === SecurityCategory.FRAMEWORK_RISK
    );
    
    const codeInjectionIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CODE_INJECTION
    );
    
    assert.ok(frameworkIssues.length > 0, 'Should detect React dangerouslySetInnerHTML usage');
    assert.ok(codeInjectionIssues.length > 0, 'Should detect eval() usage');
    
    // Check for useEffect infinite loop detection
    const infiniteLoopIssues = frameworkIssues.filter(issue =>
      issue.message.includes('useEffect') || issue.message.includes('无限循环')
    );
    
    console.log(`Framework issues: ${frameworkIssues.length}, Code injection: ${codeInjectionIssues.length}`);

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 4: ChatGPT Express.js Server with Security Issues
   * Based on common ChatGPT responses for Express server setup
   */
  test('ChatGPT Express Server - Should detect configuration vulnerabilities', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical ChatGPT Express.js server example
    const chatgptExpressCode = `
const express = require('express');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const app = express();
const PORT = process.env.PORT || 3000;

// Dangerous CORS configuration
app.use(cors({
  origin: '*', // Allows all origins - security risk
  credentials: true
}));

app.use(express.json());

// Hardcoded JWT secret
const JWT_SECRET = 'my-super-secret-key-123';

// Hardcoded admin credentials
const ADMIN_USERNAME = 'admin';
const ADMIN_PASSWORD = 'admin123';

// Login endpoint with hardcoded credentials
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  // Dangerous: Direct password comparison
  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
    const token = jwt.sign({ username }, JWT_SECRET);
    res.json({ token });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});

// Vulnerable SQL query construction
app.get('/users/:id', (req, res) => {
  const { id } = req.params;
  
  // SQL injection vulnerability
  const query = \`SELECT * FROM users WHERE id = \${id}\`;
  
  // Simulated database query
  console.log('Executing query:', query);
  res.json({ user: 'data' });
});

// Debug mode enabled in production
app.use((err, req, res, next) => {
  if (process.env.NODE_ENV === 'production') {
    // Still showing debug info in production
    res.status(500).json({ 
      error: err.message,
      stack: err.stack, // Exposing stack trace
      debug: true
    });
  } else {
    next(err);
  }
});

app.listen(PORT, () => {
  console.log(\`Server running on port \${PORT}\`);
  console.log('Debug mode:', process.env.DEBUG || 'true');
});
`;

    const document = await vscode.workspace.openTextDocument({
      content: chatgptExpressCode,
      language: 'javascript'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`ChatGPT Express test: Found ${issues.length} issues`);
    
    // Should detect various configuration issues
    const configIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CONFIG_ERROR
    );
    
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    const codeInjectionIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CODE_INJECTION
    );
    
    console.log(`Config issues: ${configIssues.length}, API key issues: ${apiKeyIssues.length}, Code injection: ${codeInjectionIssues.length}`);
    
    // Should detect hardcoded secrets and dangerous configurations
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded JWT secret and credentials');
    
    // Test that issues have proper Chinese messages
    issues.forEach(issue => {
      assert.ok(issue.message, 'Issue should have a message');
      assert.ok(typeof issue.message === 'string', 'Message should be a string');
    });

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 5: ChatGPT Python Flask API with Security Issues
   * Based on ChatGPT responses for Python web development
   */
  test('ChatGPT Python Flask API - Should detect Python-specific vulnerabilities', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical ChatGPT Python Flask example
    const chatgptPythonCode = `
from flask import Flask, request, jsonify
import sqlite3
import os
import subprocess

app = Flask(__name__)

# Hardcoded secret key
app.secret_key = 'my-secret-key-12345'

# Hardcoded database credentials
DATABASE_URL = 'postgresql://user:password123@localhost/mydb'
API_KEY = 'sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_SHORT'

@app.route('/users/<user_id>')
def get_user(user_id):
    # SQL injection vulnerability
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    # Dangerous: Direct string interpolation
    query = f"SELECT * FROM users WHERE id = {user_id}"
    cursor.execute(query)
    
    result = cursor.fetchone()
    conn.close()
    
    return jsonify(result)

@app.route('/execute', methods=['POST'])
def execute_command():
    command = request.json.get('command')
    
    # Command injection vulnerability
    result = subprocess.run(f"ls {command}", shell=True, capture_output=True, text=True)
    
    return jsonify({
        'output': result.stdout,
        'error': result.stderr
    })

@app.route('/eval', methods=['POST'])
def evaluate_code():
    code = request.json.get('code')
    
    # Code injection vulnerability
    try:
        result = eval(code)
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': str(e)})

@app.route('/admin/delete_users')
def delete_all_users():
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    
    # Dangerous: DELETE without WHERE clause
    cursor.execute("DELETE FROM users")
    
    conn.commit()
    conn.close()
    
    return jsonify({'message': 'All users deleted'})

if __name__ == '__main__':
    # Debug mode in production
    app.run(debug=True, host='0.0.0.0', port=5000)
`;

    const document = await vscode.workspace.openTextDocument({
      content: chatgptPythonCode,
      language: 'python'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`ChatGPT Python test: Found ${issues.length} issues`);
    
    // Should detect various Python-specific issues
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    const sqlIssues = issues.filter(issue => 
      issue.category === SecurityCategory.SQL_DANGER
    );
    
    const codeInjectionIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CODE_INJECTION
    );
    
    console.log(`API key issues: ${apiKeyIssues.length}, SQL issues: ${sqlIssues.length}, Code injection: ${codeInjectionIssues.length}`);
    
    // Verify detection of critical issues
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded API keys and secrets');
    assert.ok(sqlIssues.length > 0, 'Should detect dangerous SQL operations');
    assert.ok(codeInjectionIssues.length > 0, 'Should detect eval() and command injection');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  /**
   * Test Case 6: ChatGPT Docker Configuration
   * Based on ChatGPT responses for containerization
   */
  test('ChatGPT Docker Configuration - Should detect container security issues', async () => {
    const services = getExtensionServices();
    assert.ok(services, 'Extension services should be available');

    // Typical ChatGPT Dockerfile example
    const chatgptDockerCode = `
# Dockerfile generated by ChatGPT
FROM node:latest

# Running as root (security risk)
USER root

# Exposing dangerous ports
EXPOSE 22 3306 5432 6379

# Hardcoded secrets in environment
ENV API_KEY=sk-proj-EXAMPLE_NOT_REAL_OPENAI_KEY_12345
ENV DB_PASSWORD=mypassword123
ENV JWT_SECRET=my-jwt-secret-key

# Copy everything (including sensitive files)
COPY . /app

WORKDIR /app

# Install packages as root
RUN npm install

# Debug mode enabled
ENV NODE_ENV=development
ENV DEBUG=true

# Start application
CMD ["npm", "start"]

# docker-compose.yml content
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
      - "22:22"    # SSH port exposed
      - "3306:3306" # MySQL port exposed
    environment:
      - API_KEY=your-api-key-here
      - DB_PASSWORD=password123
      - DEBUG=true
    volumes:
      - .:/app
      - /etc/passwd:/etc/passwd:ro  # Mounting sensitive files
`;

    const document = await vscode.workspace.openTextDocument({
      content: chatgptDockerCode,
      language: 'dockerfile'
    });

    const issues = await services.analysisEngine.analyzeDocument(document);
    
    console.log(`ChatGPT Docker test: Found ${issues.length} issues`);
    
    // Should detect configuration and API key issues
    const configIssues = issues.filter(issue => 
      issue.category === SecurityCategory.CONFIG_ERROR
    );
    
    const apiKeyIssues = issues.filter(issue => 
      issue.category === SecurityCategory.API_KEY
    );
    
    console.log(`Config issues: ${configIssues.length}, API key issues: ${apiKeyIssues.length}`);
    
    // Verify detection of container security issues
    assert.ok(apiKeyIssues.length > 0, 'Should detect hardcoded secrets in Docker environment');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  suiteTeardown(async () => {
    // Clean up any remaining documents
    await vscode.commands.executeCommand('workbench.action.closeAllEditors');
  });
});